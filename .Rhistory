}
constraints=tlim
# if (!(exists(constraints['C'] & exists(constraints['Acc'])))) stop('constraints must be named correctly.')
select.max <- match.arg(select.max, c('MCI.Sp+MCI.Se', 'MCI.C', 'MCI.Acc','MCI.Se', 'MCI.Sp', 'MCI.n', 'All'), several.ok = TRUE)
d=simple_roc3(test[ref==0], test[ref==1]) #head(d)
totpos=length(test[ref==1])                          # The total number of positives (one number)
totneg=length(test[ref==0])                          # The total number of negatives (one number)
d$tot=rowSums(d[,c('d0','d1')])                             # Number of patients w/ each test result
# d$TN=unname(cumsum(tab[,1]))
d$TN=totneg-d$FP
d$FN=totpos-d$TP
# d$fnr=d$FN/totpos  # 1-d$FP/totneg         # 1 - specificity (false positives)
d$Y = d$tpr-d$fpr # Youden index
Yt= which.max(d$Y) # Youden threshold as row number
# getrangeTP(c(1,5))
if (controlshigher) r = 1:Yt else r = Yt:nrow(d) # r = true pos; -r = true neg
Acc.Y = (sum(d$d0[-r])+sum(d$d1[r]))/ (totpos+totneg)
# Conc = emp.AUC(test[ref==0], test[ref==1])
Conc = simple_auc(test[ref==0], test[ref==1]) # norm=test[ref==0]; abnorm=test[ref==1]
lr = nrow(d)
tab = as.matrix(d[,c('d0','d1')])
pt=prop.table(addmargins(tab,2),2)
p0 = totneg/(totpos+totneg); p1=totpos/(totpos+totneg) # p0=p1=.5
# A=Yt
Loss.Y = weights[1]*sum(pt[r, 1]) +  # FP
weights[3]*sum(pt[-r, 2])   # FN
# is = Yt # is = get.intersection(ref = ref, test = test, model='ordinal')
# intersection='Youden'
if (is.null(intersection)) {
is = get.intersection(ref = ref, test = test, model='ordinal', ...)
} else if (is.numeric(intersection)) {
is=intersection
} else if (intersection=="Youden"){
is = d$test[Yt]
}  # closest test value
intersection
isr = round(is[length(is)]) # tail has highest density
wr = which(d$testscores==isr) # row number # isr=-4
drows=nrow(d)
drows
# limits=c(1,5); getselTP(limits)
getselTP = function(limits){
selTP = logical(drows)
if (wr < limits[1] | wr > limits[2]) {NA
} else {if (controlshigher) {selTP[limits[1]:wr] = TRUE
} else {selTP[wr:limits[2]] = TRUE} }
selTP
}
upperbound = c(wr:drows) # row numbers, not test scores!
lowerbound = c(wr:1)
ui= as.data.frame(expand.grid(lowerbound,upperbound))
colnames(ui) <- c('lowerbound', 'upperbound')
ui.grid = ui[,1:2]
x = c(3,3)
sel = logical(drows); sel[x[1]:x[2]] = TRUE
sel
x
getselTP(x)
tab[!selTP & sel,1]
tab[selTP,2]
(sum(tab[!selTP & sel,1])+sum(tab[selTP,2]))
sum(tab[(x[1]:x[2]),c(1,2)])
(sum(tab[!selTP & sel,1])+sum(tab[selTP,2]))/
sum(tab[(x[1]:x[2]),c(1,2)])
selTP
!selTP & sel,1
!selTP & sel
!selTP
selTP
selTP = getselTP(x)
selTP
tab[selTP,2]
sum(tab[selTP,2])
tab[!selTP & sel,1]
(sum(tab[!selTP & sel,1])+sum(tab[selTP,2]))/
sum(tab[(x[1]:x[2]),c(1,2)])
quality.threshold(ref, test,2,4, model='ordinal')
quality.threshold(ref, test,3,3, model='ordinal')
ui.ordinal(ref, -test, select.max='All', return.all = T)
quality.threshold.uncertain(ref, test,-2,-4, intersection=-3, model='ordinal')
threshold = -4; threshold.upper=-2; intersection=-3; model = 'ordinal';
test=-test; tests=F; direction='auto'
df=check.data(ref, test, model=model)
stopifnot(!is.null(threshold.upper))
if (is.null(intersection)) {
intersection = tail(get.intersection(ref, test, model=model),1)
if (length(intersection) > 1) {
intersection=tail(intersection, n=1)
warning('More than one point of intersection. Highest used.')
}
if (direction == 'auto'){
if (mean(df$test[ref==0]) > mean(df$test[ref==1])) {
direction = '>'
} else {
direction = '<'
}
direction
negate = (direction == '>')
negate
table(ref, test)
if (negate) {
df$test = -df$test
threshold = -threshold
threshold.upper = -threshold.upper
intersection = -intersection
}
intersection
table(ref, test)
table(df$ref, df$test)
ref=df$ref
test=df$test
if (tests){
# chisq test equal probability of two frequencies
chisq1 <- function(x){
E <- sum(x)/(length(x)) # equal frequencies expected
if (all(E >= 5)) {
X2=sum((x - E)^ 2 / E)
return(c(n=x[1], n=x[2], sum=sum(x), X2=round(X2,3), df= 1,
p=round(pchisq(X2, df=1, lower.tail=F),3))) } else
return(c(n1=x[1], n2=x[2], sum=sum(x), X2=NA, df= 1, p=NA))
}
# chisq test 2x2 table
# x=matrix(c(TN,FP,FN,TP), byrow=T, nrow=2)
chisq2 <- function(x){
n = sum(x)
rs <- rowSums(x)
cs <- colSums(x)
if(n==0) return(c(n0=cs[1], n1=cs[2], sum=sum(cs), X2=NA, df= 1, p=NA))
E <- outer(rs, cs, FUN="*") / n
if (all(E >= 5)) {
YATES <- min(0.5, abs(x - E))
X2=sum((abs(x - E) - YATES) ^ 2 / E)
return(c(n=cs[1], n=cs[2], sum=sum(cs), X2=round(X2,3), df= 1,
p=round(pchisq(X2, df=1, lower.tail=F),3)))
} else return(c(n0=cs[1], n1=cs[2], sum=sum(cs), X2=NA, df= 1, p=NA))
}
if (threshold.upper < threshold) { temp=threshold; threshold=threshold.upper;
threshold.upper=temp}
threshold
threshold.upper
threshold=unname(unlist(threshold)) # threshold=ua[1]
threshold.upper=unname(unlist(threshold.upper)) # threshold.upper=NULL
stopifnot(threshold <= intersection | threshold.upper >= intersection)
certain.sel = (test < threshold) | (test > threshold.upper)
table(df$ref[!certain.sel], df$test[!certain.sel])
test.uc = test[!certain.sel] # sum(!certain.sel); length(test.uc)
ref.uc = ref[!certain.sel] # length(ref.uc)
y.hat=numeric(length(ref.uc))
y.hat
y.hat[test.uc >= intersection]=1
y.hat
TP = sum(y.hat==1 & ref.uc==1)
TP
FP = sum(y.hat==1 & ref.uc==0)
FP
TN = sum(y.hat==0 & ref.uc==0)
TN
FN = sum(y.hat==0 & ref.uc==1)
FN
# test.uc = p0; ref.uc = d0
t0 = test.uc[ref.uc==0]; n0 = as.numeric(length(t0));
t1 = test.uc[ref.uc==1]; n1 = as.numeric(length(t1));
n0
t1 = test.uc[ref.uc==1]; n1 = as.numeric(length(t1));
n1
prevalence=(TP+FN)/(TP+FP+FN+TN)
sensitivity = TP/(TP+FN)
specificity = TN/(FP+TN)
positive.predictive.value=TP/(TP+FP)
negative.predictive.value=TN/(FN+TN)
correct.classification.rate=(TP+TN)/(TP+FP+FN+TN)
balance.correct.incorrect=(TP+TN)/(FP+FN)
ta=addmargins(matrix(c(TN,FP,FN,TP),2,2))
ta
if (negate) {
threshold = -threshold
threshold.upper = - threshold.upper
intersection = -intersection
lowername = '0 (intersection < test <= threshold.upper)'
uppername = '1 (threshold.lower <= test <= intersection)'
} else {
lowername = '0 (threshold.lower <= test < intersection)'
uppername = '1 (intersection <= test <= threshold.upper)'
}
dimnames(ta)=list(UI.class=c(lowername, uppername, 'Sum'), ref= c('0', '1', 'Sum'))
if (threshold.upper < threshold) { temp=threshold; threshold=threshold.upper;
threshold.upper=temp}
threshold
threshold.upper
pt = addmargins(prop.table(ta[1:2,1:2], margin=2))
pt
SNPV = pt[1,1]/pt[1,3] # specificity / (specificity + 1 - sensitivity)
SPPV = pt[2,2]/pt[2,3] # sensitivity / (sensitivity + 1 - specificity)
likelihood.ratio.neg = pt[1,2]/pt[1,1] # (1-sensitivity)/specificity
likelihood.ratio.pos = pt[2,2]/pt[2,1] # sensitivity /(1-specificity)
r = rank(c(t1,t0))
cstat = (sum(r[1:n1]) - n1*(n1+1)/2) / (n1*n0)
cstat
tests
out = list(intersection=intersection,
table=ta,
cut=c(threshold.lower=threshold, threshold.upper=threshold.upper),
indices=c(Proportion.True=prevalence,
UI.CCR=correct.classification.rate,
UI.balance=balance.correct.incorrect,
UI.Sp =specificity,
UI.Se =sensitivity,
UI.NPV =negative.predictive.value,
UI.PPV=positive.predictive.value,
UI.SNPV = SNPV,
UI.SPPV = SPPV,
'UI.LR-' = likelihood.ratio.neg,
'UI.LR+' = likelihood.ratio.pos,
# UI.balance.with.without = bww,
UI.C=cstat))
out
source('J:/UU/Git UncertainInterval/R/quality.threshold.uncertain.R')
ref = c(rep(0, length(test0)), rep(1, length(test1)))
test = c(test0, test1)
ui.ordinal(ref, -test, select.max='All', return.all = T)
quality.threshold.uncertain(ref, -test,-2,-4, intersection=-3, model='ordinal')
quality.threshold(ref, -test,-2,-4, model='ordinal')
table(df$ref[!certain.sel], df$test[!certain.sel])
table(ref[!certain.sel], test[!certain.sel])
table(ref, test)
table(ref[certain.sel], test[certain.sel])
source('J:/UU/Git UncertainInterval/R/quality.threshold.R')
quality.threshold(ref, -test,-2,-4, model='ordinal')
quality.threshold.uncertain(ref, -test,-3,-3, intersection=-3, model='ordinal')
quality.threshold(ref, test,-3,-3, model='ordinal')
quality.threshold(ref, -test,-3,-3, model='ordinal')
table(ref, test)
plotMD(ref, test, model='ordinal') # visual inspection
barplotMD(ref, test)
quality.threshold.uncertain(ref, test,2,4, intersection=3, model='ordinal')
quality.threshold(ref, test,2,4, model='ordinal')
quality.threshold.uncertain(ref, -test,-2,-4, intersection=-3, model='ordinal')
quality.threshold(ref, -test,-2,-4, model='ordinal')
source('J:/UU/Git UncertainInterval/R/quality.threshold.uncertain.R')
source('J:/UU/Git UncertainInterval/R/quality.threshold.R')
quality.threshold.uncertain(ref, -test,-2,-4, intersection=-3, model='ordinal')
quality.threshold(ref, -test,-2,-4, model='ordinal')
table(ref, -test)
plotMD(ref, -test, model='ordinal') # visual inspection
barplotMD(ref, -test)
packageDescription(lib.loc = .)
setwd("J:/UU/Git UncertainInterval")
packageDescription(lib.loc = "J:/UU/Git UncertainInterval")
packageDescription(pkg="UncertainInterval", lib.loc = "J:/UU/Git UncertainInterval")
packageDescription(pkg="UncertainInterval")
# RPV
set.seed(1)
ref=c(rep(0,1000), rep(1, 1000))
test=round(c(rnorm(1000, 5, 1), rnorm(1000, 8, 2)))
RPV(ref, test, reliability = .9, roll.length = 3)
RPV(ref, -test, reliability = .9, roll.length = 3)
source('J:/UU/Git UncertainInterval/R/reliable.predictive.values.R', encoding = 'UTF-8')
RPV(ref, test, reliability = .9, roll.length = 3)
# RPV
library(zoo)
RPV(ref, test, reliability = .9, roll.length = 3)
pretest.prob = NULL; reliability=.9; roll.length = 3; extend = TRUE;
decision.odds = 2; decision.use = 'standardized.pv'; digits=3;
preselected.thresholds=c(NULL, NULL); use.perc=F; show.table=F
# require(zoo)
df = check.data(ref,test, 'ordinal')
ref = df$ref
test = df$test
decision.use
is.even <- function(x) x %% 2 == 0 # is.even(F)
percent <- function(x, digits = digits, format = "f", ...) {
paste0(formatC(100 * x, format = format, digits = digits, ...), "%")
}
mktxtseq <- function(r) {  # r = c(3, 7,8, 10)
d = abs(diff(c(-Inf, r)))
w = which(d != 1)
ranges = list()
for (i in (1:(length(w) - 1))) {
ranges[i] = paste(r[w[i]], r[(w[i + 1] - 1)], sep = ' to ')
}
ranges[i + 1] = paste(r[w[i + 1]], r[length(r)], sep = ' to ')
unlist(ranges)
}
if ((is.null(reliability) & is.null(roll.length))) {
roll.length=1
reliability=1
}
if (!is.null(reliability)) {
if (is.factor(test)) {
SEM = sd(as.numeric(as.character(test))) * sqrt(1 - reliability)
} else
SEM = sd(test) * sqrt(1 - reliability)
if (is.null(roll.length)) roll.length = round(SEM*2+1) # roll.length=NA
}
if (is.null(roll.length)) roll.length = 1
if (is.even(roll.length)){roll.length = roll.length-1}
if (roll.length <= 1) {
roll.length=1
warning("roll.length is set to 1. No smoothing applied.")
}
# include test scores with zero counts
if (is.numeric(test)) test = factor(test, ordered=TRUE,
levels = min(test):max(test))
if (is.numeric(ref)) ref = factor(ref, ordered=T, levels = min(ref):max(ref))
tt = table(ref, test)
ts.npv = rollsum(tt[1,], roll.length, fill=NA)/
(rollsum(tt[2,]+tt[1,],roll.length, fill=NA))
ts.ppv = 1- ts.npv
st0 = sum(tt[1,])
st1 = sum(tt[2,])
sample.prevalence = st1/(st0+st1)
if (is.null(pretest.prob)) pretest.prob = sample.prevalence
ts.ilr = (rollsum(tt[2,], roll.length, fill=NA)*st0)/
(rollsum(tt[1,],roll.length, fill=NA)*st1)
ts.sppv =  (rollsum(tt[2,], roll.length, fill=NA)/st1)/
((rollsum(tt[2,], roll.length, fill=NA)/st1)+
(rollsum(tt[1,],roll.length, fill=NA)/st0))
ts.snpv =  (rollsum(tt[1,], roll.length, fill=NA)/st0)/
((rollsum(tt[1,], roll.length, fill=NA)/st0)+
(rollsum(tt[2,],roll.length, fill=NA)/st1))
if (is.null(preselected.thresholds)){
decuse = paste('Decision use = ', decision.use, '.', sep='')
} else {
decuse = 'Decision use = preselected.thresholds.'
}
if (extend & any(is.na(ts.npv))){
ext = rbind(paste('Reliable Predictive Values for scores ',
paste(names(which(is.na(ts.npv))), collapse=' '),
' have been extended.'),
unname(decuse))
ts2.npv=na.fill(ts.npv, fill=c('extend', NA, 'extend'))
ts2.ppv=na.fill(ts.ppv, fill=c('extend', NA, 'extend'))
ts2.snpv=na.fill(ts.snpv, fill=c('extend', NA, 'extend'))
ts2.sppv=na.fill(ts.sppv, fill=c('extend', NA, 'extend'))
ts2.ilr=na.fill(ts.ilr, fill=c('extend', NA, 'extend'))
} else {
ext = rbind('No extension has been applied.', unname(decuse))
ts2.npv=ts.npv
ts2.ppv=ts.ppv
ts2.snpv=ts.snpv
ts2.sppv=ts.sppv
ts2.ilr=ts.ilr
}
pretest.odds = pretest.prob/(1-pretest.prob)
posttest.odds = pretest.odds * ts2.ilr # posttest.odss = Inf
posttest.prob = ifelse (is.infinite(posttest.odds) & posttest.odds > 0, 1,
posttest.odds/(posttest.odds+1))
rel.conf.level = pnorm((roll.length-1)/2, 0, SEM) - pnorm(-(roll.length-1)/2, 0, SEM)
if (decision.use == 'LR') {
limit = decision.odds    # limit is likelihood ratio (default 2 to 1)
} else {
limit = decision.odds/(decision.odds+1) # probability
}
arg1 = c(round(c(pretest.prob = pretest.prob, sample.prevalence=sample.prevalence,
reliability=reliability, SEM=SEM, roll.length=roll.length,
rel.conf.level=rel.conf.level, decision.odds=decision.odds,
limit=limit), digits)) # as.numeric(arg1[1])*2
ttcols = 1:ncol(tt);
names(ttcols)=colnames(tt) # levels(test)
if (is.null(preselected.thresholds)){
if (decision.use == 'predictive.value'){
pd = which(ts2.ppv > limit)
if (decision.odds < 1){
nd = ttcols[-pd]
ud = NA
} else {
nd = which(ts2.npv > limit)
ud = which(ts2.ppv <= limit & ts2.npv <= limit)
}
} else if (decision.use == 'posttest.probability'){
pd = which(posttest.prob > limit)
if (decision.odds < 1){
nd = ttcols[-pd]
ud = NA
} else {
nd = which((1-posttest.prob) > limit)
ud = which(posttest.prob <= limit & ((1-posttest.prob) <= limit)) }
} else if (decision.use == 'standardized.pv'){
if (decision.odds < 1){
pd = which(ts2.sppv > limit)
nd = ttcols[-pd]
ud = NA
} else {
pd = which(ts2.sppv > limit)
nd =
ud = which(ts2.snpv <= limit & (ts2.sppv <= limit))
}
} else if (decision.use == 'LR'){
if (decision.odds < 1){
pd = which(ts2.ilr > limit)
nd = ttcols[-pd]
ud = NA
} else {
pd = which(ts2.ilr > limit)
nd = which(ts2.ilr < 1/limit)
ud = which(ts2.ilr <= limit & (ts2.ilr >= 1/limit))
}
} else { # preselected.thresholds = c(25.2,25.1)
numlevels = as.numeric(levels(test))
if (preselected.thresholds[2] > preselected.thresholds[1]){ # positive decisions for higher scores
pd = which(numlevels > preselected.thresholds[2])
nd = which(numlevels < preselected.thresholds[1])
ud = which(numlevels >= preselected.thresholds[1]  & (as.numeric(levels(test)) < preselected.thresholds[2]))
} else { # positive decisions for lower scores
pd = which(numlevels < preselected.thresholds[2])
nd = which(numlevels > preselected.thresholds[1])
ud = which(numlevels >= preselected.thresholds[2]  & (as.numeric(levels(test)) <= preselected.thresholds[1]))
}
names(pd)=colnames(tt)[pd]
names(nd)=colnames(tt)[nd]
names(ud)=colnames(tt)[ud]
}
TN = sum(tt[1, nd]) # tt[1,nd]
FN = sum(tt[2, nd])
u0 = sum(tt[1, ud])
u1 = sum(tt[2, ud])
FP = sum(tt[1, pd])
TP = sum(tt[2, pd])
if (show.table) {
showtable = addmargins(matrix(c(TN,FN,u0,u1,FP,TP), ncol=2, byrow=T,
dimnames=list(c('Negative decisions','Uncertain',
'Positive decisions'),c("0","1"))))
}
pv = as.matrix(rbind(rnpv=round(ts2.npv, digits), rppv = round(ts2.ppv, digits),
rsnpv=round(ts2.snpv, digits), rsppv=round(ts2.sppv, digits),
rilr=round(ts2.ilr,digits), rpt.odds = round(posttest.odds,digits), rpt.prob = round(posttest.prob, digits)))
if (roll.length==1) row.names(pv) = c('npv', 'ppv', 'snpv', 'sppv', 'ilr', 'pt.odds', 'pt.prob')
col.title = c('Negative Decisions', 'Uncertain', 'Positive Decisions')
nd
preselected.thresholds[1]
decision.use
decision.odds
which(ts2.sppv > limit)
which(ts2.snpv <= limit & (ts2.sppv <= limit))
limit
source('J:/UU/Git UncertainInterval/R/reliable.predictive.values.R', encoding = 'UTF-8')
RPV(ref, test, reliability = .9, roll.length = 3)
RPV(ref, test, pretest.prob = .5, reliability = .9, roll.length = 3)
RPV(ref, -test, reliability = .9, roll.length = 3)
table(ref, -test)
set.seed(1)
ref=c(rep(0,1000), rep(1, 1000))
test=round(c(rnorm(1000, 5, 1), rnorm(1000, 8, 2)))
RPV(ref, test, reliability = .9, roll.length = 3)
RPV(ref, -test, reliability = .9, roll.length = 3)
source('J:/UU/Git UncertainInterval/R/reliable.predictive.values.R', encoding = 'UTF-8')
set.seed(1)
ref=c(rep(0,1000), rep(1, 1000))
test=round(c(rnorm(1000, 5, 1), rnorm(1000, 8, 2)))
RPV(ref, test, reliability = .9, roll.length = 3)
RPV(ref, -test, reliability = .9, roll.length = 3)
source('J:/UU/Git UncertainInterval/R/ui.ordinal.R')
xx=
xx= 3
xx=
xx= 3
xx=
install.packages("pander")
install.packages("R.rsp")
install.packages("rticles")
install.packages("MASS")
devtools::check("C:/Users/User/Documents/Revolution/mypackage")
install.packages("devtools")
setwd("J:/UU/Git UncertainInterval")
Sys.getenv("R_GSCMD")
Sys.setenv(R_GSCMD = "C:\\Program Files\\gs\\gs9.52\\bin\\gswin64c.exe")
Sys.getenv("R_GSCMD")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which('make')
Sys.getenv("R_GSCMD")
Sys.setenv(R_GSCMD = "C:\\Program Files\\gs\\gs9.52\\bin\\gswin64c.exe")
Sys.getenv("R_GSCMD")
library(UncertainInterval)
tools::buildVignettes(dir = ".", tangle=TRUE)
dir.create("inst/doc")
dir.create("inst\\doc")
dir.create(".\\inst\\doc")
setwd("J:/UU/Git UncertainInterval")
browseVignettes("UncertainInterval")
library(UncertainInterval)
browseVignettes("UncertainInterval")
devtools::install(build_vignettes = T)
library(UncertainInterval)
appDir <- system.file("shiny-examples", "UI", package = "UncertainInterval")
appDir
library(UncertainInterval)
runExample.UI()
library(UncertainInterval)
runExample.GreyZone()
?shiny::stopApp
library(rhub)
cran_prep <- check_for_cran()
Sys.setenv(R_GSCMD = "C:\\Program Files\\gs\\gs9.52\\bin\\gswin64c.exe")
Sys.getenv(R_GSCMD)
Sys.getenv("R_GSCMD")
Sys.setenv(R_GSCMD = "C:\\Program Files\\gs\\gs9.52\\bin\\gswin64c.exe")
install_github("landsheer/UncertainInterval")
devtools::install_github("landsheer/UncertainInterval")
devtools::install_github("HansLandsheer/UncertainInterval")
install.packages("htmltools")
devtools::install_github("HansLandsheer/UncertainInterval")
remove.packages("UncertainInterval", lib="~/R/win-library/4.0")
devtools::install_github("HansLandsheer/UncertainInterval")
library(UncertainInterval)
install.packages("C:/Users/Hans/Downloads/UncertainInterval-0.7.0.tar.gz", repos = NULL, type = "source")
devtools::install_github("r-lib/pkgdown", build_vignettes = TRUE)
library(UncertainInterval)
browseVignettes("UncertainInterval")
devtools::build_vignettes()
.Last.error.trace
devtools::build_vignettes()
library(UncertainInterval)
