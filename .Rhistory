} else if (is.numeric(intersection)) {
is=intersection
} else if (intersection=="Youden"){
is = d$test[Yt]
}  # closest test value
isr = round(is[length(is)]) # tail has highest density
wr = which(d$test==isr) # row number
dl=nrow(d)
upperbound = c(wr:dl) # row numbers, not test scores!
lowerbound = c(wr:1)
ui= as.data.frame(expand.grid(lowerbound,upperbound))
colnames(ui) <- c('lowerbound', 'upperbound')
# x = c(1,5)
fUI.Sp = function (x){ifelse(x[1] < wr, sum(tab[x[1]:(wr-1),1]), 0)/sum(tab[x[1]:x[2],1])}
fUI.Se = function (x){sum(tab[wr:x[2],2])/sum(tab[x[1]:x[2],2])}
fUI.Acc = function(x) {
(ifelse(x[1] < wr, sum(tab[x[1]:(wr-1),1]), 0)+sum(tab[wr:x[2],2]))/
sum(tab[(x[1]:x[2]),1]+tab[(x[1]:x[2]),2]) }
fUI.ratio = function (x){(sum(tab[x[1]:x[2],2])/totpos)/(sum(tab[x[1]:x[2],1])/totneg)}
# fUI.C = function (x){sel = test>=d$test[x[1]] & test<=d$test[x[2]] # cbind(test,sel)
#                         emp.AUC(test[sel & ref==0], test[sel & ref==1])} # ref=ref[sel]; test=test[sel]
fUI.C2 = function (x){sel = test>=d$test[x[1]] & test<=d$test[x[2]] # cbind(test,sel)
AUC(test[sel & ref==0], test[sel & ref==1])} # ref=ref[sel]; test=test[sel]
f.UI.n = function(x){ sum(d$tot[x[1]:x[2]]) }
ui$UI.Sp = apply(ui, 1, fUI.Sp) # x = unlist(ui[1,])
ui$UI.Se = apply(ui, 1, fUI.Se)
ui$UI.Acc = apply(ui[,1:2], 1, fUI.Acc)
ui$UI.ratio = apply(ui[,1:2], 1, fUI.ratio) # x=c(3,3); fUI.ratio(x)
# ui$UI.C2 = apply(ui[,1:2], 1, fUI.C)
ui$UI.C = apply(ui[,1:2], 1, fUI.C2)
ui$UI.n = apply(ui[,1:2], 1, f.UI.n)
f.Sp = function(x) {
sum(d$d0[-(x[1]:dl)])/sum(d$d0[-(x[1]:x[2])]) }
f.Se = function(x) {
sum(d$d1[-(1:x[2])])/sum(d$d1[-(x[1]:x[2])]) }
f.Acc = function(x) {
(sum(d$d0[-(x[1]:dl)])+sum(d$d1[-(1:x[2])]))/
sum(d$d0[-(x[1]:x[2])]+d$d1[-(x[1]:x[2])]) }
# f.C = function (x){sel = test>=d$test[x[1]] & test<=d$test[x[2]] # cbind(test,sel)
#    emp.AUC(test[!sel & ref==0], test[!sel & ref==1])} # ref=ref[sel]; test=test[sel]
f.C2 = function (x){sel = test>=d$test[x[1]] & test<=d$test[x[2]] # cbind(test,sel)
AUC(test[!sel & ref==0], test[!sel & ref==1])} # ref=ref[sel]; test=test[sel]
f.Loss = function(x) {
weights[1]*sum(t[-(x[1]:lr), '1']) + # FNR
weights[2]*sum(abs(t[x[1]:x[2], '0'] - t[x[1]:x[2], '1'])) + # errors for the uncertain interval
weights[3]*sum(t[-(1:x[2]), '0'])  # FPR
}
f.MCI.n = function(x){ sum(d$tot[-(x[1]:x[2])]) } # x=c(4,4); f.Loss(x)
ui$MCI.Sp = apply(ui, 1, f.Sp)
ui$MCI.Se = apply(ui, 1, f.Se)
ui$MCI.Acc = apply(ui[,1:2], 1, f.Acc)
# ui$MCI.C = apply(ui[,1:2], 1, f.C)
ui$MCI.C = apply(ui[,1:2], 1, f.C2)
ui$MCI.n = apply(ui[,1:2], 1, f.MCI.n)
ui$Loss = apply(ui[,1:2], 1, f.Loss)
# ui$Random.loss= Acc.Y - ((round(ui$MCI.Acc*ui$MCI.n)+
#                                p1*ui$UI.n)/ (totpos+totneg))
# replace row numbers by test values
ui$lowerbound =  d$test[ui$lowerbound]
ui$upperbound =  d$test[ui$upperbound]
# sel = ui$Loss <= Loss.Y
# ui2 = ui[sel,]
# ui2 = ui2[order(ui2$Loss),]
C.lim = ui$UI.C[find.closest(ui$UI.C, constraints['C'])]
Acc.lim = ui$UI.Acc[find.closest(ui$UI.Acc, constraints['Acc'])]
sel = ui$UI.C <= C.lim &  ui$UI.Acc <= Acc.lim
sel
ui2 = ui[sel,]
ui2
sel = ui2$UI.ratio >= constraints['lower.ratio'] &
ui$UI2.ratio <= constraints['upper.ratio']
sel
ui2
sel = ui2$UI.ratio >= constraints['lower.ratio'] &
ui$UI2.ratio <= constraints['upper.ratio']
ui2
sum(sel)
if (sum(sel) >= 1) {ui2 = ui2[sel,]} else warning('No solution found for the ui ratio constraints. \n')
ui2
select.max
if ('All' %in% select.max) {
ui3 = ui2[order(ui2$Loss),]
}  else {
if ('MCI.Sp+MCI.Se' %in% select.max){
sel = ui$Loss <= Loss.Y
if (sum(sel) == 0) warning('No solution found with less loss than Youden threshold. \n')
# select at least one
ui3 = ui2[which.max(unlist(ui2['MCI.Se']+ui2['MCI.Sp'])),]
rownames(ui3) <- c('MCI.Sp+MCI.Se')
select.max = select.max[!select.max %in% 'MCI.Sp+MCI.Se']
} else { ui3 = ui2[FALSE,] } # empty data.frame
i=1
while (select.max[i] %in% c('MCI.C', 'MCI.Se', 'MCI.Sp', 'MCI.Acc', 'MCI.n'))
{
temp = nrow(ui3)
ui3 = rbind(ui3,ui2[which.max(unlist(ui2[select.max[i]])),])
rownames(ui3)[temp+1] <- select.max[i]
i=i+1
}
}
ui2
ui3
ui2[order(ui2$Loss),]
# Ultrasound for hepatic mets	Tosteson and Begg (1988)
df=read.csv(file='tostbegg2.csv') # pepe page 118
data(tostbegg2)
addmargins(table(tostbegg2$type, tostbegg2$d))
table(tostbegg2$d)
prop.table(table(tostbegg2$y, tostbegg2$d), margin=2)
breaks = c(min(tostbegg2$y)-.5, seq(min(tostbegg2$y), max(tostbegg2$y))+.5)
plotMD(ref=tostbegg2$d, test=tostbegg2$y, model='ordinal')
ui.ordinal(ref=tostbegg2$d, test=tostbegg2$y, return.all = T)
source('D:/_Local/#PUBLIKATIES/_R code DiagnosisMed/DiagnosisMed3/Branches/UI feb 2018/R/ui.ordinal.R')
ui.ordinal(ref=tostbegg2$d, test=tostbegg2$y, return.all = T)
norm=tostbegg2$y[tostbegg2$d==0]
abnorm=tostbegg2$y[tostbegg2$d==1]
Youden(norm, abnorm)
# A short test with 5 ordinal values
test0     = rep(1:5, times=c(165,14,16,55, 10)) # test results norm group
test1     = rep(1:5, times=c( 15,11,13,55,164)) # test results of patients
ref = c(rep(0, length(test0)), rep(1, length(test1)))
test = c(test0, test1)
table(ref, test)
plotMD(ref, test, model='ordinal') # visual inspection
ui.ordinal(ref, test, select.max='All')
source('D:/_Local/#PUBLIKATIES/_R code DiagnosisMed/DiagnosisMed3/Branches/UI feb 2018/R/ui.ordinal.R')
ui.ordinal(ref, test, select.max='All')
intersection=NULL; weights=c(1,1,1);
constraints=c( Acc=.6, lower.ratio=.8, upper.ratio=1.25)
select.max="All"
find.closest <- function(M, crit){
M[which(is.na(M))] = Inf # crit+10e10
mindiff=min(abs(M-crit)) # warning: no non-missing arguments to min; returning Inf
which((M == crit+mindiff) | (M == crit-mindiff), arr.ind=T)
}
AUC <- function(norm, abnorm){
n1 = as.numeric(length(abnorm));
n0 = as.numeric(length(norm));
r = rank(c(abnorm,norm))
(sum(r[1:n1]) - n1*(n1+1)/2) / (n1*n0)
}
tlim = c(C=.57, Acc=.6, lower.ratio=.8, upper.ratio=1.25)
if (is.null(names(constraints))) {
tlim[1:length(constraints)] = constraints
} else {
if (all(names(constraints) %in% c("C" , "Acc" , "lower.ratio" , "upper.ratio"))){
tlim[names(constraints)] = constraints[names(constraints)]}
}
constraints=tlim
# if (!(exists(constraints['C'] & exists(constraints['Acc'])))) stop('constraints must be named correctly.')
select.max <- match.arg(select.max, c('MCI.Sp+MCI.Se', 'MCI.C', 'MCI.Acc','MCI.Se', 'MCI.Sp', 'MCI.n', 'All'), several.ok = TRUE)
tab=as.matrix(table( test, ref))
# print(addmargins(tab))
totpos=sum(tab[,2])                          # The total number of positives (one number)
totneg=sum(tab[,1])                          # The total number of negatives (one number)
d=data.frame(test=unique(sort(test)), d0=tab[,'0'], d1=tab[,'1'], row.names=1:nrow(tab))
d$tot=rowSums(tab)                             # Number of patients w/ each test result
d$TP=unname(rev(cumsum(rev(tab[,2]))))     # Number of true positives, start with maximum
d$FP=unname(rev(cumsum(rev(tab[,1]))))     # Number of false positives, start with maximum
# d$TN=unname(cumsum(tab[,1]))
d$TN=totneg-d$FP
d$FN=totpos-d$TP
d$tpr=d$TP/totpos          # Sensitivity (fraction true positives)
d$fpr=d$FP/totneg  # 1-d$FP/totneg         # 1 - specificity (false positives)
# d$fnr=d$FN/totpos  # 1-d$FP/totneg         # 1 - specificity (false positives)
d$Y = d$tpr-d$fpr # Youden index
Yt= which.max(d$Y) # Youden threshold as row number
# Hmisc::find.matches(d$Y, max(d$Y), tol=c(.0001))
# d$Y[4] > d$Y[3]
# which( d$Y == max(d$Y) )
Acc.Y = (sum(d$d0[1:(Yt-1)])+sum(d$d1[(Yt):nrow(d)]))/ (totpos+totneg)
# Conc = emp.AUC(test[ref==0], test[ref==1])
Conc = AUC(test[ref==0], test[ref==1])
lr = nrow(tab)
t=prop.table(addmargins(table(test, ref),2),2)
p0 = totneg/(totpos+totneg); p1=totpos/(totpos+totneg) # p0=p1=.5
# A=Yt
Loss1 = function(A) {
lr = nrow(t)
weights[1]*sum(t[-(A:lr), '1']) +  # FN
weights[3]*sum(t[A:lr, '0'])   # FP
}
Loss.Y = Loss1(Yt) # Yt = rownumber; Loss = 1 - max.Youden
# is = Yt # is = get.intersection(ref = ref, test = test, model='ordinal')
# intersection='Youden'
if (is.null(intersection)) {
is = get.intersection(ref = ref, test = test, model='ordinal', ...)
} else if (is.numeric(intersection)) {
is=intersection
} else if (intersection=="Youden"){
is = d$test[Yt]
}  # closest test value
isr = round(is[length(is)]) # tail has highest density
wr = which(d$test==isr) # row number
dl=nrow(d)
upperbound = c(wr:dl) # row numbers, not test scores!
lowerbound = c(wr:1)
ui= as.data.frame(expand.grid(lowerbound,upperbound))
colnames(ui) <- c('lowerbound', 'upperbound')
# x = c(1,5)
fUI.Sp = function (x){ifelse(x[1] < wr, sum(tab[x[1]:(wr-1),1]), 0)/sum(tab[x[1]:x[2],1])}
fUI.Se = function (x){sum(tab[wr:x[2],2])/sum(tab[x[1]:x[2],2])}
fUI.Acc = function(x) {
(ifelse(x[1] < wr, sum(tab[x[1]:(wr-1),1]), 0)+sum(tab[wr:x[2],2]))/
sum(tab[(x[1]:x[2]),1]+tab[(x[1]:x[2]),2]) }
fUI.ratio = function (x){(sum(tab[x[1]:x[2],2])/totpos)/(sum(tab[x[1]:x[2],1])/totneg)}
# fUI.C = function (x){sel = test>=d$test[x[1]] & test<=d$test[x[2]] # cbind(test,sel)
#                         emp.AUC(test[sel & ref==0], test[sel & ref==1])} # ref=ref[sel]; test=test[sel]
fUI.C2 = function (x){sel = test>=d$test[x[1]] & test<=d$test[x[2]] # cbind(test,sel)
AUC(test[sel & ref==0], test[sel & ref==1])} # ref=ref[sel]; test=test[sel]
f.UI.n = function(x){ sum(d$tot[x[1]:x[2]]) }
ui$UI.Sp = apply(ui, 1, fUI.Sp) # x = unlist(ui[1,])
ui$UI.Se = apply(ui, 1, fUI.Se)
ui$UI.Acc = apply(ui[,1:2], 1, fUI.Acc)
ui$UI.ratio = apply(ui[,1:2], 1, fUI.ratio) # x=c(3,3); fUI.ratio(x)
# ui$UI.C2 = apply(ui[,1:2], 1, fUI.C)
ui$UI.C = apply(ui[,1:2], 1, fUI.C2)
ui$UI.n = apply(ui[,1:2], 1, f.UI.n)
f.Sp = function(x) {
sum(d$d0[-(x[1]:dl)])/sum(d$d0[-(x[1]:x[2])]) }
f.Se = function(x) {
sum(d$d1[-(1:x[2])])/sum(d$d1[-(x[1]:x[2])]) }
f.Acc = function(x) {
(sum(d$d0[-(x[1]:dl)])+sum(d$d1[-(1:x[2])]))/
sum(d$d0[-(x[1]:x[2])]+d$d1[-(x[1]:x[2])]) }
# f.C = function (x){sel = test>=d$test[x[1]] & test<=d$test[x[2]] # cbind(test,sel)
#    emp.AUC(test[!sel & ref==0], test[!sel & ref==1])} # ref=ref[sel]; test=test[sel]
f.C2 = function (x){sel = test>=d$test[x[1]] & test<=d$test[x[2]] # cbind(test,sel)
AUC(test[!sel & ref==0], test[!sel & ref==1])} # ref=ref[sel]; test=test[sel]
f.Loss = function(x) {
weights[1]*sum(t[-(x[1]:lr), '1']) + # FNR
weights[2]*sum(abs(t[x[1]:x[2], '0'] - t[x[1]:x[2], '1'])) + # errors for the uncertain interval
weights[3]*sum(t[-(1:x[2]), '0'])  # FPR
}
f.MCI.n = function(x){ sum(d$tot[-(x[1]:x[2])]) } # x=c(4,4); f.Loss(x)
ui$MCI.Sp = apply(ui, 1, f.Sp)
ui$MCI.Se = apply(ui, 1, f.Se)
ui$MCI.Acc = apply(ui[,1:2], 1, f.Acc)
# ui$MCI.C = apply(ui[,1:2], 1, f.C)
ui$MCI.C = apply(ui[,1:2], 1, f.C2)
ui$MCI.n = apply(ui[,1:2], 1, f.MCI.n)
ui$Loss = apply(ui[,1:2], 1, f.Loss)
ui
# replace row numbers by test values
ui$lowerbound =  d$test[ui$lowerbound]
ui$upperbound =  d$test[ui$upperbound]
# sel = ui$Loss <= Loss.Y
# ui2 = ui[sel,]
# ui2 = ui2[order(ui2$Loss),]
C.lim = ui$UI.C[find.closest(ui$UI.C, constraints['C'])]
Acc.lim = ui$UI.Acc[find.closest(ui$UI.Acc, constraints['Acc'])]
C.lim
Acc.lim
constraints['Acc']
ui
sel = ui$UI.C <= C.lim &  ui$UI.Acc <= Acc.lim
Acc.lim
C.lim
# sel = ui$Loss <= Loss.Y
# ui2 = ui[sel,]
# ui2 = ui2[order(ui2$Loss),]
C.lim = ui$UI.C[find.closest(ui$UI.C, constraints['C'])[1]]
Acc.lim = ui$UI.Acc[find.closest(ui$UI.Acc, constraints['Acc'][1])]
C.lim
Acc.lim
sel = ui$UI.C <= C.lim &  ui$UI.Acc <= Acc.lim
# sel = ui$Loss <= Loss.Y
# ui2 = ui[sel,]
# ui2 = ui2[order(ui2$Loss),]
C.lim = ui$UI.C[find.closest(ui$UI.C, constraints['C'])][1]
C.lim
Acc.lim = ui$UI.Acc[find.closest(ui$UI.Acc, constraints['Acc'])][1]
Acc.lim
sel = ui$UI.C <= C.lim &  ui$UI.Acc <= Acc.lim
ui2 = ui[sel,]
sel = ui2$UI.ratio >= constraints['lower.ratio'] &
ui$UI2.ratio <= constraints['upper.ratio']
ui2
ui2$UI.ratio >= constraints['lower.ratio']
ui$UI2.ratio <= constraints['upper.ratio']
constraints['upper.ratio']
sel = ui2$UI.ratio >= constraints['lower.ratio'] &
ui$UI.ratio <= constraints['upper.ratio']
constraints['lower.ratio']
constraints['upper.ratio']
sel = ui2$UI.ratio >= constraints['lower.ratio'] &
ui$UI.ratio <= constraints['upper.ratio']
sel = ui2$UI.ratio >= constraints['lower.ratio'] &
ui2$UI.ratio <= constraints['upper.ratio']
if (sum(sel) >= 1) {ui2 = ui2[sel,]} else warning('No solution found for the ui ratio constraints. \n')
source('D:/_Local/#PUBLIKATIES/_R code DiagnosisMed/DiagnosisMed3/Branches/UI feb 2018/R/ui.ordinal.R')
ui.ordinal(ref, test, select.max='All')
# forcing the Youden threshold as intersection gives the same best result.
# However, the estimates for ui.Se, ui.Sp and ui.Acc differ.
ui.ordinal(ref, test, intersection='Youden')
# Sa me solution but other layout
ui.ordinal(ref, test, select.max=c('MCI.Sp+MCI.Se', 'MCI.C', 'MCI.Acc', 'MCI.Se', 'MCI.Sp', 'MCI.n'))
# forcing the Youden threshold as intersection gives the same best result for lowest loss.
# However, the estimates for ui.Se, ui.Sp and ui.Acc differ:
ui.ordinal(ref, test, intersection='Youden')
#'
nobs=1000
set.seed(6)
Z0 <- rnorm(nobs, mean=0)
b0=seq(-5, 8, length.out=31)
f0=cut(Z0, breaks = b0, labels = c(1:30))
x0=as.numeric(levels(f0))[f0]
Z1 <- rnorm(nobs, mean=1, sd=1.5)
f1=cut(Z1, breaks = b0, labels = c(1:30))
x1=as.numeric(levels(f1))[f1]
ref=c(rep(0,nobs), rep(1,nobs))
test=c(x0,x1)
ui.ordinal(ref, test)
ui.binormal(ref, test) # compare application of the bi-normal model
plotMD(ref, test, model='ordinal')
plotMD(ref, test, model='binormal')
source('D:/_Local/#PUBLIKATIES/_R code DiagnosisMed/DiagnosisMed3/Branches/UI feb 2018/R/ui.ordinal.R')
ui.ordinal(ref=tostbegg2$d, test=tostbegg2$y)
ui.ordinal(ref=tostbegg2$d, test=tostbegg2$y, return.all = T)
ui.ordinal(ref=tostbegg2$d, test=tostbegg2$y)
ui.ordinal(ref=tostbegg2$d, test=tostbegg2$y)
Se = .55; Sp = .55; distribution = 'norm'; parameters.d0 = c(mean = 0; sd = 1);
Se = .55; Sp = .55; distribution = 'norm'; parameters.d0 = c(mean = 0, sd = 1);
parameters.d1 = c(mean = 1, sd = 1); overlap.interval = NULL; intersection = NULL;
start = NULL; print.level = 0
if (Se <= .5) stop('Value <= .5 invalid for Se of the uncertain interval')
if (Sp <= .5) stop('Value <= .5 invalid for Sp of the uncertain interval')
c01 = Sp / (1 - Sp)
c11 = Se / (1 - Se)
d0 = get(paste('d', distribution, sep = ""))
args=formals(d0)
m = match(names(parameters.d0), names(args))
if (any(is.na(m)))
stop(paste(
"'parameters.d0' specifies names which are not arguments to", deparse(d0)[1]
))
args[m] = parameters.d0
formals(d0) <- args # d0(2) ; dnorm(2, 0, 1)
d1 = get(paste('d', distribution, sep = ""))
m = match(names(parameters.d1), names(args))
if (any(is.na(m)))
stop(paste(
"'parameters.d1' specifies names which are not arguments to", deparse(d1)[1]
))
args[m] = parameters.d1
formals(d1) <- args # d1(2) ; dnorm(2, 1, 1)
p0 = get(paste('p', distribution, sep = ""))
args=formals(p0)
m = match(names(parameters.d0), names(args))
if (any(is.na(m)))
stop(paste(
"'parameters.d0' specifies names which are not arguments to", deparse(p0)[1]
))
args[m] = parameters.d0
formals(p0) <- args # p0(2) ; pnorm(2, 0, 1)
p1 = get(paste('p', distribution, sep = ""))
m = match(names(parameters.d1), names(args))
if (any(is.na(m)))
stop(paste(
"'parameters.d1' specifies names which are not arguments to", deparse(p1)[1]
))
args[m] = parameters.d1
formals(p1) <- args # p1(2) ; pnorm(2, 1, 1)
q0 = get(paste('q', distribution, sep = ""))
m = match(names(parameters.d0), names(args))
if (any(is.na(m)))
stop(paste(
"'parameters.d0' specifies names which are not arguments to", deparse(q0)[1]
))
args[m] = parameters.d0
formals(q0) <- args # p1(2) ; qnorm(.001, 0, 1)
q1 = get(paste('q', distribution, sep = ""))
m = match(names(parameters.d1), names(args))
if (any(is.na(m)))
stop(paste(
"'parameters.d1' specifies names which are not arguments to", deparse(q1)[1]
))
args[m] = parameters.d1
formals(q1) <- args # p1(2) ; qnorm(.001, 1, 1)
cat('function call d0: ', deparse(d0), '\n' )
cat('function call d1: ', deparse(d1), '\n' )
cat('function call p0: ', deparse(p0), '\n' )
cat('function call p1: ', deparse(p1), '\n' )
cat('function call q0: ', deparse(q0), '\n' )
cat('function call q1: ', deparse(q1), '\n' )
qnorm(.001, 1, 1)
q1(.001)
q1(p=.001)
q1(q=.001)
q0 = get(paste('q', distribution, sep = ""))
args=formals(q0)
m = match(names(parameters.d0), names(args))
if (any(is.na(m)))
stop(paste(
"'parameters.d0' specifies names which are not arguments to", deparse(q0)[1]
))
args[m] = parameters.d0
formals(q0) <- args # p1(2) ; qnorm(.001, 0, 1)
q1 = get(paste('q', distribution, sep = ""))
m = match(names(parameters.d1), names(args))
if (any(is.na(m)))
stop(paste(
"'parameters.d1' specifies names which are not arguments to", deparse(q1)[1]
))
args[m] = parameters.d1
formals(q1) <- args # p1(2) ; qnorm(.001, 1, 1); q1(q=.001)
cat('function call q0: ', deparse(q0), '\n' )
cat('function call q1: ', deparse(q1), '\n' )
c(q1(.001), q0(.999))
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
Sys.which(Sys.getenv("R_QPDF", "Rtools"))
Sys.which(Sys.getenv("R_QPDF", "Rtools"))
Sys.which(Sys.getenv("R_QPDF", "qpdf"))
47/51
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
res70$solution
invBoxCox(res70$solution, p1$roundlam)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
intersect.binormal <- function(m1, sd1, m2, sd2, p1=.5, p2=.5){
B <- (m1/sd1^2 - m2/sd2^2)
A <- 0.5*(1/sd2^2 - 1/sd1^2)
C <- 0.5*(m2^2/sd2^2 - m1^2/sd1^2) - log((sd1/sd2)*(p2/p1))
if (A!=0){
(-B + c(1,-1)*sqrt(B^2 - 4*A*C))/(2*A)
} else {-C/B}
}
x = seq(-5,8,length=1000)
mu0=0; sd0=1; mu1=2; sd1=2
y0 <- dnorm(x,mu0, sd0)
y1 <- dnorm(x, mu1, sd1)
is=intersect.binormal(mu0, sd0, mu1, sd1)
plot(x,y0,type='l', col='green', xlab='predictor', ylab='density', main='Figure 1')
lines(x,y1,type='l', col='black')
legend('topright', legend=c('H0', 'H1'), lty=c(1,1), col=c('green', 'black'), cex=.7)
threshold = qnorm(.90, mu0, sd0) # allowing a FPR of .1
abline(v=c(is[2], threshold), col=c( 'red', 'black'))
text(1.9, 0.03, expression(alpha), col='green')
text(0, 0.03, expression(beta), col='black')
library(UncertainInterval)
data(psa2b)
names(psa2b)
plotMD(psa2b$d, psa2b$tpsa)
abline(v=4, col='red')
t2 = table (psa2b$tpsa > 4, psa2b$d)
rownames(t2) <- c('PSA <= 4', 'PSA > 4')
library(knitr)
kable(addmargins(t2), caption = "Table 1")
(res=ui.nonpar(psa2b$d, psa2b$tpsa))
(out=quality.threshold(psa2b$d, psa2b$tpsa, res[1], res[2]))
(t2 = quality.threshold.uncertain(psa2b$d, psa2b$tpsa, res[1], res[2]))
sel = psa2b$tpsa >= res[1] & psa2b$tpsa <= res[2]
plotMD(psa2b$d[sel], psa2b$tpsa[sel])
kable(t2$table, caption = "Table 2")
(res=ui.nonpar(psa2b$d, psa2b$tpsa, sens=.60, spec=.60))
quality.threshold(psa2b$d, psa2b$tpsa, res[1], res[2])$indices[c('specificity',  'sensitivity')]
(res=ui.nonpar(psa2b$d, psa2b$tpsa, sens=.65, spec=.65))
quality.threshold(psa2b$d, psa2b$tpsa, res[1], res[2])$indices[c('specificity',  'sensitivity')]
(res=ui.nonpar(psa2b$d, psa2b$tpsa, sens=.70, spec=.70))
quality.threshold(psa2b$d, psa2b$tpsa, res[1], res[2])$indices[c('specificity',  'sensitivity')]
library(UncertainInterval)
library(car)
data(psa2b)
p1 = powerTransform(psa2b$tpsa)
t_tpsa = bcPower(psa2b$tpsa, p1$roundlam)
qqPlot(t_tpsa[psa2b$d==0])
qqPlot(t_tpsa[psa2b$d==1])
plotMD(psa2b$d, t_tpsa, model='binormal', position.legend = 'topleft')
(res1=ui.binormal(psa2b$d, t_tpsa))
abline(v=res1$solution, col= 'red')
invBoxCox <- function(x, lambda)
if (lambda == 0) exp(x) else (lambda*x + 1)^(1/lambda)
invBoxCox(res1$solution, p1$roundlam)
outlier_values <- boxplot.stats(t_tpsa)$out  # outlier values.
inds <- which(t_tpsa %in% outlier_values)
table(outlier_values, psa2b$d[inds])
boxplot(t_tpsa, main="", boxwex=0.1)
# mtext(paste("Outliers: ", paste(round(outlier_values, 2), collapse=", ")), # cex=0.6)
sel=t_tpsa > -3
plotMD(psa2b$d[sel], t_tpsa[sel], model='binormal')
(res55=ui.binormal(psa2b$d[sel], t_tpsa[sel]))
abline(v=res55$solution, col= 'red')
invBoxCox <- function(x, lambda)
if (lambda == 0) exp(x) else (lambda*x + 1)^(1/lambda)
invBoxCox(res55$solution, p1$roundlam)
res60=ui.binormal(psa2b$d[sel], t_tpsa[sel], Se=.60, Sp=.60)
res60$results
quality.threshold.uncertain(psa2b$d, t_tpsa, res60$solution[1], res60$solution[2])$indices[c('specificity',  'sensitivity')]
quality.threshold(psa2b$d, t_tpsa, res60$solution[1], res60$solution[2])$indices[c('specificity',  'sensitivity')]
res65=ui.binormal(psa2b$d[sel], t_tpsa[sel], Se=.65, Sp=.65)
res65$results
quality.threshold.uncertain(psa2b$d, t_tpsa, res65$solution[1], res65$solution[2])$indices[c('specificity',  'sensitivity')]
quality.threshold(psa2b$d, t_tpsa, res65$solution[1], res65$solution[2])$indices[c('specificity',  'sensitivity')]
res70=ui.binormal(psa2b$d[sel], t_tpsa[sel], Se=.70, Sp=.70)
res70$results
quality.threshold.uncertain(psa2b$d, t_tpsa, res70$solution[1], res70$solution[2])$indices[c('specificity',  'sensitivity')]
quality.threshold(psa2b$d, t_tpsa, res70$solution[1], res70$solution[2])$indices[c('specificity',  'sensitivity')]
quality.threshold(psa2b$d, t_tpsa, res55$solution[1], res55$solution[2])$table
quality.threshold(psa2b$d, t_tpsa, res60$solution[1], res60$solution[2])$table
quality.threshold(psa2b$d, t_tpsa, res65$solution[1], res65$solution[2])$table
quality.threshold(psa2b$d, t_tpsa, res70$solution[1], res70$solution[2])$table
res70$solution
invBoxCox(res70$solution, p1$roundlam)
data("tostbegg2")
sel = tostbegg2$type==0
plotMD(ref=tostbegg2$d, test=tostbegg2$y, model='ordinal')
ui.ordinal(ref=tostbegg2$d, test=tostbegg2$y, return.all=TRUE)
